'use client';
import React, { useState, useEffect } from 'react';
import {
  VStack,
  HStack,
  Text,
  Button,
  useColorModeValue,
  Box,
  Flex,
  Heading,
  Spacer,
  ChakraProvider,
} from '@chakra-ui/react';
import ContentBox from './contentbox'; // Adjust path as needed
import PDFUploaderAndViewer from './components/reviewer_doc'; // Adjust path as needed
import RevPDFUploaderAndViewer from './components/reviewee_doc';
import EditableTextArea from './components/eval_questions';
import ReadableTextArea from './components/get_answers';
import { ArrowUpIcon, ArrowDownIcon, ArrowUpDownIcon } from '@chakra-ui/icons';

export default function MyPage() {
  const boxBg = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('white', 'gray.700');

  const [showControls, setShowControls] = useState(false);
  const [leftWidth, setLeftWidth] = useState(50);
  const [isDragging, setIsDragging] = useState(false);

  const [boxStates, setBoxStates] = useState({
    1: { file: undefined }, // ID and corresponding state
    2: {},
    3: {},
    4: {},
    5: {},
  });

  const initialLeftBoxes = [
    { id: 1, title: 'Reviewer Document', content: 'The reviewer document is used to generate evaluation questions.', component: (
      <PDFUploaderAndViewer
      />
    ) },
    { id: 2, title: 'Document Evaluation', content: 'Evaluation questions are used to evaluate the document to review: they are generated by AI, but can also be edited by users.', component: <EditableTextArea/> },
    
  ];

  const initialRightBoxes = [
    { id: 3, title: 'Document to Review', content: 'The document to review is evaluated with the evaluation questions.', component: <RevPDFUploaderAndViewer />},
    { id: 4, title: 'Document Chat', content: 'Chat with either document. Reference reviewer document with @doc1 and document to review with @doc2. Example: @doc1 summarize the data management plan. ', component: <ReadableTextArea/> },
  ];

  const [leftBoxes, setLeftBoxes] = useState(initialLeftBoxes);
  const [rightBoxes, setRightBoxes] = useState(initialRightBoxes);

  const handleMouseDown = () => setIsDragging(true);
  const handleMouseUp = () => setIsDragging(false);

  const handleMouseMove = (e: { clientX: number; }) => {
    if (isDragging) {
      const newWidth = (e.clientX / window.innerWidth) * 100;
      if (newWidth > 20 && newWidth < 80) {
        setLeftWidth(newWidth);
      }
    }
  };

  useEffect(() => {
    if (isDragging) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
    } else {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    }

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging]);

  const moveBox = (id: React.Key | null | undefined, direction: string) => {
    const sourceBoxes = leftBoxes.some(box => box.id === id) ? leftBoxes : rightBoxes;
    const targetBoxes = sourceBoxes === leftBoxes ? rightBoxes : leftBoxes;
    const boxIndex = sourceBoxes.findIndex(box => box.id === id);

    const movingBox = sourceBoxes[boxIndex];
    
    if (direction === "switch_sides") {
      const updatedSourceBoxes = sourceBoxes.filter(box => box.id !== id);
      const updatedTargetBoxes = [...targetBoxes, movingBox];
      setLeftBoxes(sourceBoxes === leftBoxes ? updatedSourceBoxes : updatedTargetBoxes);
      setRightBoxes(sourceBoxes === leftBoxes ? updatedTargetBoxes : updatedSourceBoxes);
    } else if (direction === 'up' && boxIndex > 0) {
      const updatedSourceBoxes = [...sourceBoxes];
      const [movedBox] = updatedSourceBoxes.splice(boxIndex, 1);
      updatedSourceBoxes.splice(boxIndex - 1, 0, movedBox);
      setLeftBoxes(sourceBoxes === leftBoxes ? updatedSourceBoxes : targetBoxes);
      setRightBoxes(sourceBoxes === rightBoxes ? updatedSourceBoxes : targetBoxes);
    } else if (direction === 'down' && boxIndex < sourceBoxes.length - 1) {
      const updatedSourceBoxes = [...sourceBoxes];
      const [movedBox] = updatedSourceBoxes.splice(boxIndex, 1);
      updatedSourceBoxes.splice(boxIndex + 1, 0, movedBox);
      setLeftBoxes(sourceBoxes === leftBoxes ? updatedSourceBoxes : targetBoxes);
      setRightBoxes(sourceBoxes === rightBoxes ? updatedSourceBoxes : targetBoxes);
    }
  };

  const renderContentBox = (box: { id: React.Key | null | undefined; title: string; content: string | number | bigint | boolean | React.ReactElement<any, string | React.JSXElementConstructor<any>> | Iterable<React.ReactNode> | React.ReactPortal | Promise<React.AwaitedReactNode> | null | undefined; component: string | number | bigint | boolean | React.ReactElement<any, string | React.JSXElementConstructor<any>> | Iterable<React.ReactNode> | React.ReactPortal | Promise<React.AwaitedReactNode> | null | undefined; }) => (
    <Box key={box.id} bg={boxBg} borderRadius="md" borderWidth="1px" borderColor={borderColor} p={4}>
      {showControls && (
        <HStack mb={2}>
          <Button size="xs" onClick={() => moveBox(box.id, 'up')}>
            <ArrowUpIcon />
          </Button>
          <Button size="xs" onClick={() => moveBox(box.id, 'down')}>
            <ArrowDownIcon />
          </Button>
          <Button size="xs" onClick={() => moveBox(box.id, 'switch_sides')}>
            <ArrowUpDownIcon transform="rotate(90deg)" />
          </Button>
        </HStack>
      )}
      <ContentBox title={box.title} children={undefined}>
        <Text>{box.content}</Text>
        {box.component}
      </ContentBox>
    </Box>
  );

  return (
    <ChakraProvider>
      <VStack spacing={0} align="stretch" minHeight="100vh">
        <Flex 
          as="nav" 
          align="center" 
          justify="space-between" 
          wrap="wrap" 
          padding="1rem" 
          bg={useColorModeValue('gray.100', 'gray.900')}
          color={useColorModeValue('gray.700', 'gray.200')}
          position="fixed" // Fixes the navbar to the viewport
          top={0} // Align to the top
          left={0} // Align to the left
          right={0} // Extend to the right
          zIndex={1000} // Ensure it's above other content
        >
          <Heading as="h1" size="lg" letterSpacing="-.1rem">
            review anything
          </Heading>
          <Spacer />
          <Button onClick={() => setShowControls(!showControls)}>
            {showControls ? 'hide controls' : 'show controls'}
          </Button>
          <Button
            onClick={() => {
              setShowControls(!showControls);
              window.open('https://docs.google.com/document/d/1bnUrPJ8PPX8_4Jra3QLFk1232ffgnMcLsibvX0E1zyQ/edit#heading=h.psi98t855m9r')
            }}
          >
            tutorials & documentation ->
          </Button>
        </Flex>

        <Flex
          mt="4rem" // Offset content below the fixed navbar
          p={8}
          justifyContent="center"
          alignItems="flex-start"
          borderRadius="md"
          position="relative"
          w="100%"
        >
          <VStack w={`${leftWidth}%`} spacing={4} align="stretch">
            {leftBoxes.map(renderContentBox)}
          </VStack>

          <div
            style={{
              width: '18px',
              cursor: 'col-resize',
              height: '100%',
              zIndex: 10,
              position: 'absolute',
              left: `${leftWidth}%`,
              top: 0,
            }}
            onMouseDown={handleMouseDown}
          ></div>

          <VStack w={`${100 - leftWidth}%`} spacing={4} align="stretch" ml="4px">
            {rightBoxes.map(renderContentBox)}
          </VStack>
        </Flex>
      </VStack>
    </ChakraProvider>
  );
}
